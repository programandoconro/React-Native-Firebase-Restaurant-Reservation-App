{"version":3,"sources":["createPointerEventsContainer.tsx"],"names":["MIN_POSITION_OFFSET","createPointerEventsContainer","Component","Container","pointerEvents","computePointerEvents","component","handleComponentRef","setNativeProps","Error","handlePositionChange","positionListener","remove","AnimatedValueSubscription","props","realPosition","navigation","scene","isStale","state","index","offset","__getAnimatedValue","Math","abs","bindPosition","React","value","callback","token","addListener","removeListener"],"mappings":"wzBAAA,oD,gIAIA,GAAMA,CAAAA,mBAAmB,CAAG,IAA5B,CAoBe,QAASC,CAAAA,4BAAT,CAGbC,SAHa,CAIgE,IACvEC,CAAAA,SADuE,8bAEnEC,aAFmE,CAEnD,MAAKC,oBAAL,EAFmD,OAGnEC,SAHmE,CAG1C,IAH0C,OAUnEC,kBAVmE,CAU9C,SAACD,SAAD,CAA4B,CACvD,MAAKA,SAAL,CAAiBA,SAAjB,CAEA,GAAIA,SAAS,EAAI,MAAOA,CAAAA,SAAS,CAACE,cAAjB,GAAoC,UAArD,CAAiE,CAC/D,KAAM,IAAIC,CAAAA,KAAJ,CAAU,kDAAV,CAAN,CACD,CACF,CAhB0E,OA0BnEC,oBA1BmE,CA0B5C,UAAqB,CAMlD,GAAI,MAAKJ,SAAT,CAAoB,CAClB,GAAMF,CAAAA,aAAa,CAAG,MAAKC,oBAAL,EAAtB,CACA,GAAI,MAAKD,aAAL,GAAuBA,aAA3B,CAA0C,CACxC,MAAKA,aAAL,CAAqBA,aAArB,CACA,MAAKE,SAAL,CAAeE,cAAf,CAA8B,CAAEJ,aAAa,CAAbA,aAAF,CAA9B,EACD,CACF,CACF,CAvC0E,qHAMpD,CACrB,KAAKO,gBAAL,EAAyB,KAAKA,gBAAL,CAAsBC,MAAtB,EAAzB,CACD,CAR0E,mDAkBpD,CACrB,KAAKD,gBAAL,EAAyB,KAAKA,gBAAL,CAAsBC,MAAtB,EAAzB,CACA,KAAKD,gBAAL,CAAwB,GAAIE,CAAAA,yBAAJ,CACtB,KAAKC,KAAL,CAAWC,YADW,CAEtB,KAAKL,oBAFiB,CAAxB,CAID,CAxB0E,mEAyC5C,iBACe,KAAKI,KADpB,CACrBE,UADqB,aACrBA,UADqB,CACTD,YADS,aACTA,YADS,CACKE,KADL,aACKA,KADL,CAG7B,GAAIA,KAAK,CAACC,OAAN,EAAiBF,UAAU,CAACG,KAAX,CAAiBC,KAAjB,GAA2BH,KAAK,CAACG,KAAtD,CAA6D,CAE3D,MAAOH,CAAAA,KAAK,CAACG,KAAN,CAAcJ,UAAU,CAACG,KAAX,CAAiBC,KAA/B,CAAuC,UAAvC,CAAoD,MAA3D,CACD,CAGD,GAAMC,CAAAA,MAAM,CAAGN,YAAY,CAACO,kBAAb,GAAoCN,UAAU,CAACG,KAAX,CAAiBC,KAApE,CACA,GAAIG,IAAI,CAACC,GAAL,CAASH,MAAT,EAAmBrB,mBAAvB,CAA4C,CAI1C,MAAO,UAAP,CACD,CAED,MAAO,MAAP,CACD,CA3D0E,uCA6DlE,CACP,KAAKyB,YAAL,GACA,KAAKrB,aAAL,CAAqB,KAAKC,oBAAL,EAArB,CAEA,MACE,qBAAC,SAAD,0BACM,KAAKS,KADX,EAEE,aAAa,CAAE,KAAKV,aAFtB,CAGE,cAAc,CAAE,KAAKG,kBAHvB,kDADF,CAOD,CAxE0E,uBACrDmB,KAAK,CAACxB,SAD+C,EA2E7E,MAAOC,CAAAA,SAAP,CACD,C,GAEKU,CAAAA,yB,YAIJ,mCAAYc,KAAZ,CAAmCC,QAAnC,CAA6E,8DAC3E,KAAKD,KAAL,CAAaA,KAAb,CACA,KAAKE,KAAL,CAAaF,KAAK,CAACG,WAAN,CAAkBF,QAAlB,CAAb,CACD,C,0FAEQ,CACP,KAAKD,KAAL,CAAWI,cAAX,CAA0B,KAAKF,KAA/B,EACD,C","sourcesContent":["import * as React from 'react';\nimport { Animated, View } from 'react-native';\nimport { NavigationStackProp, Scene } from '../../types';\n\nconst MIN_POSITION_OFFSET = 0.01;\n\nexport type PointerEvents = 'box-only' | 'none' | 'auto';\n\nexport type InputProps = {\n  scene: Scene;\n  navigation: NavigationStackProp;\n  realPosition: Animated.Value;\n};\n\nexport type InjectedProps = {\n  pointerEvents: PointerEvents;\n  onComponentRef: (ref: View | null) => void;\n};\n\n/**\n * Create a higher-order component that automatically computes the\n * `pointerEvents` property for a component whenever navigation position\n * changes.\n */\nexport default function createPointerEventsContainer<\n  Props extends InjectedProps & InputProps\n>(\n  Component: React.ComponentType<Props>\n): React.ComponentType<Pick<Props, Exclude<keyof Props, keyof InjectedProps>>> {\n  class Container extends React.Component<Props> {\n    private pointerEvents = this.computePointerEvents();\n    private component: View | null = null;\n    private positionListener: AnimatedValueSubscription | undefined;\n\n    componentWillUnmount() {\n      this.positionListener && this.positionListener.remove();\n    }\n\n    private handleComponentRef = (component: View | null) => {\n      this.component = component;\n\n      if (component && typeof component.setNativeProps !== 'function') {\n        throw new Error('Component must implement method `setNativeProps`');\n      }\n    };\n\n    private bindPosition() {\n      this.positionListener && this.positionListener.remove();\n      this.positionListener = new AnimatedValueSubscription(\n        this.props.realPosition,\n        this.handlePositionChange\n      );\n    }\n\n    private handlePositionChange = (/* { value } */) => {\n      // This should log each frame when releasing the gesture or when pressing\n      // the back button! If not, something has gone wrong with the animated\n      // value subscription\n      // console.log(value);\n\n      if (this.component) {\n        const pointerEvents = this.computePointerEvents();\n        if (this.pointerEvents !== pointerEvents) {\n          this.pointerEvents = pointerEvents;\n          this.component.setNativeProps({ pointerEvents });\n        }\n      }\n    };\n\n    private computePointerEvents() {\n      const { navigation, realPosition, scene } = this.props;\n\n      if (scene.isStale || navigation.state.index !== scene.index) {\n        // The scene isn't focused.\n        return scene.index > navigation.state.index ? 'box-only' : 'none';\n      }\n\n      // @ts-ignore\n      const offset = realPosition.__getAnimatedValue() - navigation.state.index;\n      if (Math.abs(offset) > MIN_POSITION_OFFSET) {\n        // The positon is still away from scene's index.\n        // Scene's children should not receive touches until the position\n        // is close enough to scene's index.\n        return 'box-only';\n      }\n\n      return 'auto';\n    }\n\n    render() {\n      this.bindPosition();\n      this.pointerEvents = this.computePointerEvents();\n\n      return (\n        <Component\n          {...this.props}\n          pointerEvents={this.pointerEvents}\n          onComponentRef={this.handleComponentRef}\n        />\n      );\n    }\n  }\n\n  return Container as any;\n}\n\nclass AnimatedValueSubscription {\n  private value: Animated.Value;\n  private token: string;\n\n  constructor(value: Animated.Value, callback: Animated.ValueListenerCallback) {\n    this.value = value;\n    this.token = value.addListener(callback);\n  }\n\n  remove() {\n    this.value.removeListener(this.token);\n  }\n}\n"]}